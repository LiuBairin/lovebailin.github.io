<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blog</title>
    <script type="module" crossorigin="" src="/assets/app-6cb5fdbe.js"></script>
    <link rel="stylesheet" href="/assets/index-db5128d5.css">
  <link rel="modulepreload" crossorigin="" href="/assets/es11-c2f7af27.js"><link rel="modulepreload" crossorigin="" href="/assets/BlTitle-e6ef2f67.js"></head>
  <body>
    <div id="app" data-server-rendered="true"><!--[--><!--[--><header h18="" px8="" py4="" flex="" justify-between="" fixed="" top-0="" left-0="" right-0="" bottom-0="" data-v-e1ae0180=""><div data-v-e1ae0180=""></div><div grid="" gap4="" grid-auto-flow-col="" text-5="" justify-items-center="" items-center="" data-v-e1ae0180=""><a href="/" c-op-70="" hover:c-op-100="" text-4="" class="!c-trueGray" data-v-e1ae0180="">Blog</a><a href="https://marketplace.visualstudio.com/search?term=BaiLin&amp;target=VSCode&amp;category=All%20categories&amp;sortBy=Relevance" c-op-70="" hover:c-op-100="" text-4="" class="!c-trueGray" i-akar-icons:vscode-fill="" data-v-e1ae0180=""></a><a href="https://github.com/lovebailin" i-ph:github-logo-bold="" c-op-70="" hover:c-op-100="" class="!c-trueGray" data-v-e1ae0180=""></a><div dark:i-ic:outline-light-mode="" i-ic:baseline-brightness-2="" cursor-pointer="" c-op-70="" hover:c-op-100="" c-truegray="" data-v-e1ae0180=""></div></div></header><header h18="" data-v-e1ae0180=""></header><!--]--><div class="write markdown-body"><!--[--><h1 class="!font900">ES2020(ES11)带来的新特性</h1><p><!--[--><span style="color:#eca441;" border="" border-current="" rounded="" border-style-solid="" px-1="" pb-0.2="" mb-0="" mr-2="">ecma</span><span style="color:#fcb737;" border="" border-current="" rounded="" border-style-solid="" px-1="" pb-0.2="" mb-0="" mr-2="">js</span><!--]--></p><p class="!mb12">11/03/2023</p><!--]--><h2 id="es2020(es11)%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7" tabindex="-1">ES2020(ES11)带来的新特性</h2><h3 id="string.prototype.matchall" tabindex="-1">String.prototype.matchAll</h3><p>我们知道，原来的 String 原型中，已经提供 <code class="">match</code> 方法，如：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello1hello2hello3'</span>
<span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello(\d+)</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">const</span> match <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>
<span class="token comment">// ["hello1", "1", index: 0, input: "hello1hello2hello3", groups: undefined]</span>
</code></pre><p>这时我们发现，他只能拿到一组匹配结果，当我们尝试在正则中加入全局 g 时。</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> matches <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ["hello1", "hello2", "hello3"]</span>
</code></pre><p>只能拿到一个只有完整匹配结果的 <code class="">string[]</code>，那种在非全局情况下复杂匹配结果没有了。</p><p>而 <code class="">matchAll</code> 就给我带来期望的结果：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> matchIterator <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// RegExpStringIterator</span>
</code></pre><p>我们发现，返回的结果是一个迭代器（<code class="">Iterator</code>），可以使用 for of 遍历。</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> matchIterator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span>
  <span class="token comment">// 第一次结果： ["hello1", "1", index: 0, input: "hello1hello2hello3", groups: undefined]</span>
<span class="token punctuation">}</span>
</code></pre><p>如果你想要数组的形式，可以通过 <code class="">...</code> 运算符或者 <code class="">Array.from()</code> 转化。</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> matches1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> matches2 <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><h3 id="bigint" tabindex="-1">BigInt</h3><p>我们熟知的 <code class="">Number</code> 类型只能安全的表示 -(2^53-1) 至 2^53-1 范的值，即 <code class="">Number.MIN_SAFE_INTEGER</code> 到 <code class="">Number.MAX_SAFE_INTEGER</code> 之间，超过则不能做到精确计算。</p><p>为了解决这个问题，引入了 <code class="">BigInt</code> 类型：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> bigIntNum1 <span class="token operator">=</span> <span class="token number">9007199254740991n</span>
<span class="token keyword">const</span> bigIntNum2 <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">9007199254740991</span><span class="token punctuation">)</span>
</code></pre><p><code class="">BigInt</code> 是跟 <code class="">Number</code> 一样，是原始数据类型：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// number</span>
<span class="token keyword">typeof</span> <span class="token number">1n</span> <span class="token comment">// bigint</span>
</code></pre><h3 id="dynamic-import-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" tabindex="-1">Dynamic import 按需加载</h3><p>ES2020 提案引入 <code class="">import()</code> 函数，支持动态加载模块：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./foo.js'</span><span class="token punctuation">)</span>
</code></pre><p>import() 返回一个 Promise 对象，我们可以在 then 中获取到相应的 export 内容。</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment">//  foo.js</span>
<span class="token keyword">export</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">export</span> b <span class="token operator">=</span> <span class="token number">2</span>

<span class="token comment">//  home.js</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./foo.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>
    <span class="token comment">// 加载成功的回调</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 加载失败的回调</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>import() 的加入解决了之前 esm 中只能顶层加入，静态解析的不足。</p><h3 id="promise.allsettled" tabindex="-1">Promise.allSettled</h3><p><code class="">Promise.allSettled</code> 提供了另外一种并发执行异步任务的处理方式。</p><p>跟我们常见的 Promise.all 相比：</p><p><code class="">allSettled</code> 需要等其中的所有任务 resolve 或 reject 后才会改变 status；<code class="">all</code> 所有任务都 resolve 后改变状态。</p><p><code class="">allSettled</code> 无论其中异步任务是 <code class="">fulfilled</code> 还是 <code class="">rejected</code>，最终状态都只有 <code class="">fulfilled</code>；<code class="">all</code> 一旦有任务的变成 <code class="">rejected</code>，本身的状态也会变成 <code class="">rejected</code>。</p><p><code class="">allSettled</code> 让我们更加自由的处理所有并发任务的结果。</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> resolved <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> rejected <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'custom error'</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>resolved<span class="token punctuation">,</span> rejected<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">results</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span>
  <span class="token comment">// [</span>
  <span class="token comment">//    { status: 'fulfilled', value: true },</span>
  <span class="token comment">//    { status: 'rejected', reason: 'custom error' }</span>
  <span class="token comment">// ]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>如上：allSettled 是不会进到 catch 回调中，在 then 回调的返回每个异步任务的结果。</p><h3 id="globalthis" tabindex="-1">globalThis</h3><p>之前，你想写同时支持 Node 和 Browser 环境的代码，获取全局对象会有点费劲：</p><ul><li>Browser 环境中，全局对象是 window，但 Node 和 Web Worker 没有 window。</li><li>Browser 和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。</li><li>Node 里面，全局对象是 global，但其他环境都不支持。</li><li>还有 this，受上下文影响，很容易出错。</li></ul><p>要获取全局对象，可以封装一个全局函数：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> self <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> self
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> window
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> global <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> global
  <span class="token punctuation">}</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'找不到全局对象'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在 ES2020 标准下，我们可以在任意上下文和环境下通过 <code class="">globalThis</code> 获取到全局对象。</p><h3 id="nullish-coalescing-operator-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">Nullish coalescing Operator 空值合并运算符</h3><p>设置默认值最常见的做法就是使用 <code class="">||</code>：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> vip <span class="token operator">=</span> userInfo<span class="token punctuation">.</span>vip <span class="token operator">||</span> <span class="token string">'非vip'</span>
</code></pre><p>但是在 JS 中空字符串，0 等在进行判断时，被当为 false 处理。上面的 vip 0 的结果就会变成 非 vip，这个显然是错误的，为了符合我们预期，我们得这么写：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> vip <span class="token operator">=</span> userInfo<span class="token punctuation">.</span>vip <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">'非vip'</span> <span class="token operator">:</span> userInfo<span class="token punctuation">.</span>vip
</code></pre><p>而使用空值合并运算符，能获得简洁的写法：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> vip <span class="token operator">=</span> userInfo<span class="token punctuation">.</span>vip <span class="token operator">??</span> <span class="token string">'非vip'</span>
</code></pre><h3 id="optional-chaining-%E5%8F%AF%E9%80%89%E9%93%BE" tabindex="-1">Optional chaining 可选链</h3><p>你是否还记得，为了判断一个多层级对象，写过以下代码：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>b <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">.</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do more</span>
<span class="token punctuation">}</span>
</code></pre><p>如果不这么做又容易获得 <code class="">TypeError</code> 成就。</p><p>在最新的可选链中，大可不必，可以这么写：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">?.</span>b<span class="token operator">?.</span>c<span class="token operator">?.</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do more</span>
<span class="token punctuation">}</span>
</code></pre><p>在 <code class="">?</code> 后面的字段，如果有就返回相应的值，没有返回 <code class="">undefined</code>：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
obj<span class="token operator">?.</span>a <span class="token comment">// 1</span>
obj<span class="token operator">?.</span>b <span class="token comment">// undefined</span>
obj<span class="token operator">?.</span>a<span class="token operator">?.</span>b <span class="token comment">// undefined</span>
</code></pre><h3 id="es2021(es12)%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB" tabindex="-1">ES2021(ES12)新特性解读</h3><h3 id="string.prototype.replaceall" tabindex="-1">String.prototype.replaceAll</h3><p>原有的 <code class="">replace</code> 如果不用正则表达式只能替换一个，相信不少初学者都塌过这个坑。</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">'112233'</span>
a<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment">// x12233</span>
</code></pre><p>如果想要全部替换，我们只能借助全局的正则表达式：</p><pre class="language-javascript"><code class="language-javascript">a<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">1</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment">// xx2233</span>
</code></pre><p>现在使用 <code class="">replaceAll</code> 不用正则也能达到一样的效果，而且更加直观：</p><pre class="language-javascript"><code class="language-javascript">a<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment">// xx2233</span>
</code></pre><h3 id="promise.any-%26-aggregateerror" tabindex="-1">Promise.any &amp; AggregateError</h3><p>继 <code class="">all</code>, <code class="">race</code>, <code class="">allSettled</code> 这些批处理方法后，又迎来了一个新的 <code class="">any</code>。</p><p><code class="">race</code> 接收 promise 数组中第一个 <code class="">reslove</code> 的值作为自身的 <code class="">reslove</code>，也就是说只要有一个 <code class="">fulfilled</code> ，它也会是 <code class="">fulfilled</code> 状态。举个例子:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> a <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'err1'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'err2'</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">ret</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>而当所有 promise 都 <code class="">rejected</code> 时，那么它将抛出一个 <code class="">AggregateError</code> 汇总错误消息：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> a <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'err1'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'err2'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'err3'</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>errors<span class="token punctuation">)</span> <span class="token comment">// ['err1', 'err2', 'err3']</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h3 id="logical-assignment-operators%EF%BC%88%E9%80%BB%E8%BE%91%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89" tabindex="-1">Logical assignment operators（逻辑赋值运算符）</h3><p><code class="">??</code>, <code class="">&amp;&amp;</code>, <code class="">||</code> 这三也加入了赋值运算符中，举个例子比较形象：</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 原有</span>
a <span class="token operator">=</span> a <span class="token operator">??</span> b
a <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> b
a <span class="token operator">=</span> a <span class="token operator">||</span> b

<span class="token comment">// 新的</span>
a <span class="token operator">??=</span> b
a <span class="token operator">&amp;&amp;=</span> b
a <span class="token operator">||=</span> b
</code></pre><p>注：跟 <code class="">a += b</code> 一样，会改变 <code class="">a</code> 的值，所以不能 <code class="">const a</code>。</p><h3 id="weakref-%26-finalizationregistry%EF%BC%88%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%91%E5%90%AC%EF%BC%89" tabindex="-1">WeakRef &amp; FinalizationRegistry（弱引用和垃圾回收监听）</h3><h4 id="weakref" tabindex="-1">WeakRef</h4><p>在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间。</p><p>而 <code class="">WeakRef</code> 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收。</p></div><!--]--></div>
    
  

</body></html>